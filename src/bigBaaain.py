from typing import List, Optional, Dict
import sys

"""
note we can't touch all the ram 256, because the las 5-6 values are used for
vmcalls for input and output, if we don't have any '.' or ',' in the program
we don't need to simulate wrapping but it is what it is.

* so we give the user 128 [0x00, 0x7f] slots/cells with simulated wrapping.
* data ptr will be in 0x80 for no particular reason
* from 0x81 to 0xf9 it may be used for utilityes
* from 0xfa to 0xff is for vm calls

ram map: | 0x00-0x7f | 0x80-0x80 | 0x81-0xf9 | 0xfa-0xff |
use:     | prog.data | data.ptr  | utils     | vmcalls   |
"""

DATA_PTR = "0x80"

###############################################################################

def gen_instructions():
    def label_generator(name):
        _c = -1
        def new_label():
            nonlocal _c
            _c += 1
            return f"{name}_0x{_c:04x}"
        return new_label

    blab = label_generator("bounce")
    elab = label_generator("loop_end")
    llab = label_generator("loop")

    # RAW dumps ###############################################################

    def raw_inc_ptr(_):
        lab = blab()
        return f"""
    ; [>]
    inc &{DATA_PTR}
    JNS &{DATA_PTR}, {lab} ; bounce check
    mov &{DATA_PTR}, 0x00
{lab}:"""
    def raw_dec_ptr(_):
        lab = blab()
        return f"""
    ; [<]
    dec &{DATA_PTR}
    JNS &{DATA_PTR}, {lab} ; bounce check
    mov &{DATA_PTR}, 0x7f
{lab}:"""

    def raw_inc_data(_):
        return f"""
    ; [+]
    inc ^{DATA_PTR}"""
    def raw_dec_data(_):
        return f"""
    ; [-]
    dec ^{DATA_PTR}"""

    def raw_read(_):
        return f"""
    ; [.]
    mov &0xff, 1 ; read call
    mov &0xfe, 0 ; stdin
    mov &0xfd, &{DATA_PTR} ; &buf
    VMCALL"""

    def raw_write(_):
        return f"""
    ; [,]
    mov &0xff, 2 ; write call
    mov &0xfe, 1 ; stdout
    mov &0xfd, &{DATA_PTR} ; &buf
    VMCALL"""

    """
    # NOTE: the jump may be to long :(
    TODO: implement lauch paths??? crazy stuff :)
    """
    def loop(state: Dict[str, List[str]]):
        end_lab = elab()
        continue_lab = llab()
        state["loop"].append(continue_lab)
        state["loop_end"].append(end_lab)
        return f"""
    ; [[]
{continue_lab}:
    JZ  ^{DATA_PTR}, {end_lab}"""
    def jump_back(state: Dict[str, List[str]]):
        end_lab = state["loop_end"].pop()
        continue_lab = state["loop"].pop()
        return f"""
    ; []]
    JMP {continue_lab}
{end_lab}:"""

    # Optimized dumps #########################################################

    def op_move_ptr(state: Dict[str, List[str]]):
        n = state["n"]
        if n < 0:
            if n == -1:  # 8B < 9B :)
                return raw_dec_ptr(state)

            lab = blab()
            return f"""
    ; [dec_ptr({n})]
    sub &{DATA_PTR}, {-n}
    JNS &{DATA_PTR}, {lab} ; bounce check
    add &{DATA_PTR}, 0xf7
{lab}:"""

        if n == 1:  # 8B < 9B :)
            return raw_inc_ptr(state)
        lab = blab()
        return f"""
    ; [inc_ptr({n})]
    add &{DATA_PTR}, {n}
    JNS &{DATA_PTR}, {lab} ; bounce check
    add &{DATA_PTR}, 0xf7
{lab}:"""

    def op_add_data(state: Dict[str, List[str]]):
        n = state["n"]
        if n < 0:
            if n == -1:
                return raw_dec_data(state)
            return f"""
    ; [sub({n})]
    sub ^{DATA_PTR}, {-n}"""

        if n == 1:  # 2B < 3B :)
            return raw_inc_data(state)
        return f"""
    ; [add({n})]
    add ^{DATA_PTR}, {n}"""

    # TODO: maybe add a -1 check?
    def op_read(state: Dict[str, List[str]]):
        if not state["op_read"]:
            return raw_write(state)
        return f"""
    ; [read]
    mov &0xfd, &{DATA_PTR} ; &buf
    VMCALL"""

    def op_write(state: Dict[str, List[str]]):
        if not state["op_write"]:
            return raw_write(state)
        return f"""
    ; [write]
    mov &0xfd, &{DATA_PTR} ; &buf
    VMCALL"""

    # instruction maps ########################################################
    return {
        '>': op_move_ptr,
        '<': op_move_ptr,
        '+': op_add_data,
        '-': op_add_data,
        '.': op_write,
        ',': op_read,
        '[': loop,
        ']': jump_back,
    }

def bb_dump_code(file: str, out: str, code: List[str]):
    with open(out, 'w', encoding='utf-8') as f:
        f.writelines(f"; autogenerated wool code from '{file}' using bigBaain.py ;\n")
        f.writelines(f"main:\n")
        f.writelines("    mov &0xfc, 1    ; setup read write count\n")
        f.writelines(f"    mov &{DATA_PTR}, 0x00 ; set pointer to 0 \n")
        instructions = gen_instructions()
        state = {
            "loop": [],
            "loop_end": [],
            "n": 0,
            "op_read": False,
            "op_write": False,
        }
        def null_f(_):
            return ""

        # TODO: if abs(n) == 127, write the cmd
        loop_char = { '[', ']' }
        math_char = { '+', '-' }
        move_char = { '>', '<' }
        n, math, move = 0, False, False
        inst, prev = None, null_f
        for c in "".join(code):
            inst = instructions.get(c)
            if inst is None:
                continue
            if math and c in math_char:
                if -127 < n and n < 127:  # flush
                    n += 1 if c == '+' else -1
                else:
                    state["n"] = n
                    f.writelines(prev(state))
                    n = 1 if c == '+' else -1
                continue
            elif math and c in move_char:
                math, move = False, True
                state["n"] = n
                f.writelines(prev(state))
                prev = inst
                n = 1 if c == '>' else -1
                continue
            elif move and c in move_char:
                if -127 < n and n < 127:  # flush
                    n += 1 if c == '>' else -1
                else:
                    state["n"] = n
                    f.writelines(prev(state))
                    n = 1 if c == '>' else -1
                continue
            elif move and c in math_char:
                math, move = True, False
                state["n"] = n
                f.writelines(prev(state))
                prev = inst
                n = 1 if c == '+' else -1
                continue
            elif not math and c in math_char:
                math, move = True, False
                n = 1 if c == '+' else -1
                f.writelines(prev(state))
                prev = inst
                continue
            elif not move and c in move_char:
                math, move = False, True
                n = 1 if c == '>' else -1
                f.writelines(prev(state))
                prev = inst
                continue
            # else:
            math, move = False, False
            state["n"] = n
            if c in loop_char:
                f.writelines(prev(state))
                state["op_read"] = False
                state["op_write"] = False
                prev = inst
            elif c == ',':
                f.writelines(prev(state))
                if not state["op_read"]:
                    f.writelines(inst(state))
                    inst = null_f
                    state["op_read"] = True
                    state["op_write"] = False
                prev = inst
            elif c == '.':
                f.writelines(prev(state))
                if not state["op_write"]:
                    f.writelines(inst(state))
                    inst = null_f
                    state["op_read"] = False
                    state["op_write"] = True
                prev = inst
        # print(state)
        f.writelines(prev(state))
        # for i, line in enumerate(code, start=1):
        #     n = 0
        #     for j, c in enumerate(line, start=1):
        #         inst = instructions.get(c)
        #         if inst is None:
        #             continue
        #         f.writelines(inst(state))
        #         n = 0
        f.writelines(f"\n    Exit 0\n")

def bb_syntax_check(file: str, code: List[str]) -> bool:
    open_brackets = []

    for row, line in enumerate(code, start=1):
        for col, c in enumerate(line, start=1):
            if c == '[':
                open_brackets.append((row, col))
            elif c == ']':
                if not open_brackets:
                    print(f"{file}:{row}:{col}:bigBaain:error: expected '['")
                    return False
                open_brackets.pop()
    
    if open_brackets:
        for row, col in open_brackets:
            print(f"{file}:{row}:{col}:bigBaain:error: unclosed '['")
        return False

    return True

def bb_load_file(file: str) -> Optional[List[str]]:
    # comment_char = ';'  # Define comment character
    # 
    # def bb_remove_comment(line: str) -> str:
    #     return line.split(comment_char, 1)[0].strip()
    #
    try:
        with open(file, 'r', encoding='utf-8') as f:
            return [line for line in f.readlines()]
    except FileNotFoundError:
        print(f"bigBaain:error: file '{file}' not found.")
    except Exception as e:
        print(f"bigBaain:error: {e}")
    return None

###############################################################################

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python script.py <in.bf> <out.wool>")
        sys.exit(1)

    input  = sys.argv[1]
    output = sys.argv[2]
    code = bb_load_file(input)

    if not bb_syntax_check(input, code):
        sys.exit(1)

    bb_dump_code(input, output, code)
    sys.exit(0)
