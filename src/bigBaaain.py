from typing import List, Optional, Dict
import sys

"""
note we can't touch all the ram 256, because the las 5-6 values are used for
vmcalls for input and output, if we don't have any '.' or ',' in the program
we don't need to simulate wrapping but it is what it is.

* so we give the user 128 [0x00, 0x7f] slots/cells with simulated wrapping.
* data ptr will be in 0x80 for no particular reason
* from 0x81 to 0xf9 it may be used for utilityes
* from 0xfa to 0xff is for vm calls

ram map: | 0x00-0x7f | 0x80-0x80 | 0x81-0xf9 | 0xfa-0xff |
use:     | prog.data | data.ptr  | utils     | vmcalls   |
"""

DATA_PTR = 0x80

###############################################################################

def gen_instructions():
    def label_generator(name):
        _c = -1
        def new_label():
            nonlocal _c
            _c += 1
            return f"{name}_0x{_c:04x}"
        return new_label
    blab = label_generator("bounce")

    def inc_ptr(_):
        lab = blab()
        return f"""
    ; [>]
    inc &{DATA_PTR}
    JS  &{DATA_PTR}, {lab} ; bounce check
    mov &{DATA_PTR}, 0x00
{lab}:"""
    def dec_ptr(_):
        lab = blab()
        return f"""
    ; [<]
    dec &{DATA_PTR}
    JNS &{DATA_PTR}, {lab} ; bounce check
    mov &{DATA_PTR}, 0x7f
{lab}:"""

    def inc_data(_):
        return f"""
    ; [+]
    inc ^{DATA_PTR}"""
    def dec_data(_):
        return f"""
    ; [-]
    dec ^{DATA_PTR}"""

    def add_data(_):
        return f"""
    ; [+]
    inc ^{DATA_PTR}"""
    def sup_data(_):
        return f"""
    ; [-]
    dec ^{DATA_PTR}"""

    # NOTE nose si es &0x80 or ^0x80
    def read(_):
        return f"""
    ; [.]
    mov &0xff, 1       ; read call
    mov &0xfe, 0       ; stdin
    mov &0xfd, &0x80   ; &buf
    mov &0xfc, 1       ; count"""

    def write(_):
        return f"""
    ; [,]
    mov &0xff, 2       ; write call
    mov &0xfe, 1       ; stdout
    mov &0xfd, &0x80   ; &buf
    mov &0xfc, 1       ; count"""

    elab = label_generator("loop_end")
    llab = label_generator("loop")
    """
    # NOTE: the jump may be to long :(
    TODO: implement lauch paths??? crazy stuff :)
    """
    def loop(state: Dict[str, List[str]]):
        end_lab = elab()
        continue_lab = llab()
        state["loop"].append(continue_lab)
        state["loop_end"].append(end_lab)
        return f"""
    ; [[]
{continue_lab}:
    JZ ^{DATA_PTR}, {end_lab}"""
    def jump_back(state: Dict[str, List[str]]):
        end_lab = state["loop_end"].pop()
        continue_lab = state["loop"].pop()
        return f"""
    ; []]
    JMP {continue_lab}
{end_lab}:"""

    return {
        '>': inc_ptr,
        '<': dec_ptr,
        '+': inc_data,
        '-': dec_data,
        '.': write,
        ',': read,
        '[': loop,
        ']': jump_back,
    }

def bb_dump_code(file: str, out: str, code: List[str]):
    with open(out, 'w', encoding='utf-8') as f:
        f.writelines(f"; autogenerated wool code from '{file}' using bigBaain.py ;\n")
        f.writelines(f"main:")
        instructions = gen_instructions()
        state = {"loop": [], "loop_end": []}
        for i, line in enumerate(code, start=1):
            for j, c in enumerate(line, start=1):
                inst = instructions.get(c)
                if inst is None:
                    continue
                f.writelines(inst(state))
        f.writelines(f"\n    Exit 0\n")

def bb_syntax_check(file: str, code: List[str]) -> bool:
    open_brackets = []

    for row, line in enumerate(code, start=1):
        for col, c in enumerate(line, start=1):
            if c == '[':
                open_brackets.append((row, col))
            elif c == ']':
                if not open_brackets:
                    print(f"{file}:{row}:{col}:bigBaain:error: expected '['")
                    return False
                open_brackets.pop()
    
    if open_brackets:
        for row, col in open_brackets:
            print(f"{file}:{row}:{col}:bigBaain:error: unclosed '['")
        return False

    return True

def bb_load_file(file: str) -> Optional[List[str]]:
    # comment_char = ';'  # Define comment character
    # 
    # def bb_remove_comment(line: str) -> str:
    #     return line.split(comment_char, 1)[0].strip()
    #
    try:
        with open(file, 'r', encoding='utf-8') as f:
            return [line for line in f.readlines()]
    except FileNotFoundError:
        print(f"bigBaain:error: file '{file}' not found.")
    except Exception as e:
        print(f"bigBaain:error: {e}")
    return None

###############################################################################

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python script.py <in.bf> <out.wool>")
        sys.exit(1)

    input  = sys.argv[1]
    output = sys.argv[2]
    code = bb_load_file(input)

    if not bb_syntax_check(input, code):
        sys.exit(1)

    bb_dump_code(input, output, code)
    sys.exit(0)
